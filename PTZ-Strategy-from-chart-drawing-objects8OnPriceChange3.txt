#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

namespace NinjaTrader.NinjaScript.Strategies
{
	public class PTZDailyPlanStrategy : Strategy
	{
//		private NinjaTrader.NinjaScript.Indicators.PropTraderz.PTZDailyPlanURLv2 ptzIndicator;

		private double lastCheckPrice;
		private DateTime lastCheckTime;
		private Dictionary<double, string> priceLevels;
		private DateTime lastLevelUpdate;

		// Track levels that have been crossed for retrace entry logic
		private Dictionary<double, LevelCrossInfo> levelCrossTracker;

		private class LevelCrossInfo
		{
			public bool CrossedAbove { get; set; }
			public bool CrossedBelow { get; set; }
			public DateTime CrossTime { get; set; }
			public string Description { get; set; }
		}

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description									= @"Trading strategy based on PTZ Daily Plan levels - buys at support/pivot bull levels, sells at resistance/pivot bear levels";
				Name										= "PTZ Daily Plan Strategy";
				Calculate									= Calculate.OnPriceChange;
				EntriesPerDirection							= 1;
				EntryHandling								= EntryHandling.AllEntries;
				IsExitOnSessionCloseStrategy				= true;
				ExitOnSessionCloseSeconds					= 30;
				IsFillLimitOnTouch							= false;
				MaximumBarsLookBack							= MaximumBarsLookBack.TwoHundredFiftySix;
				OrderFillResolution							= OrderFillResolution.Standard;
				Slippage									= 0;
				StartBehavior								= StartBehavior.WaitUntilFlat;
				TimeInForce									= TimeInForce.Gtc;
				TraceOrders									= false;
				RealtimeErrorHandling						= RealtimeErrorHandling.StopCancelClose;
				StopTargetHandling							= StopTargetHandling.PerEntryExecution;
				BarsRequiredToTrade							= 20;
				IsInstantiatedOnEachOptimizationIteration	= true;

				// Strategy Parameters
				UseSupport									= true;
				UseResistance								= true;
				UsePivotBull								= true;
				UsePivotBear								= true;
				UseStrengthConfirmed						= false;
				UseWeaknessConfirmed						= false;

				PriceProximityTicks							= 2;
				TradeOnCrossover							= true;
				TradeOnTouch								= true;

				EnableStopLoss								= false;
				StopLossTicks								= 20;
				EnableProfitTarget							= false;
				ProfitTargetTicks							= 40;

				EnableTrailStop								= false;
				TrailStopTicks								= 15;

				// LBL Filter
				UseLBLFilter								= false;
				RequireLBLInDescription						= false;

				// Keywords (must match indicator settings)
				KeywordSupport								= "Support";
				KeywordResistance							= "Resistance";
				KeywordPivotBull							= "Pivot Bull";
				KeywordPivotBear							= "Pivot Bear";
				KeywordStrengthConfirmed					= "Strength Confirmed";
				KeywordWeaknessConfirmed					= "Weakness Confirmed";
			}
			else if (State == State.Configure)
			{
			}
			else if (State == State.DataLoaded)
			{
//				ptzIndicator = PTZDailyPlanURLv2();
//				AddChartIndicator(ptzIndicator);

				lastCheckPrice = 0;
				lastCheckTime = DateTime.MinValue;
				priceLevels = new Dictionary<double, string>();
				lastLevelUpdate = DateTime.MinValue;
				levelCrossTracker = new Dictionary<double, LevelCrossInfo>();
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < BarsRequiredToTrade)
				return;

//			if (ptzIndicator == null)
//				return;

			// Update price levels from chart drawing objects
			if (Time[0].Date != lastLevelUpdate.Date || priceLevels.Count == 0)
			{
				UpdatePriceLevelsFromChart();
				lastLevelUpdate = Time[0];
			}

			// Get current and previous price
			double currentPrice = Close[0];
			double previousPrice = lastCheckPrice > 0 ? lastCheckPrice : Close[Math.Max(0, CurrentBar - 1)];

			// Update cross tracking for all levels
			UpdateLevelCrossTracking(currentPrice, previousPrice);

			// Check for price level interactions
			CheckForBuySignals(currentPrice, previousPrice);
			CheckForSellSignals(currentPrice, previousPrice);

			// Update last check values
			lastCheckPrice = currentPrice;
			lastCheckTime = Time[0];
		}

		private void UpdateLevelCrossTracking(double currentPrice, double previousPrice)
		{
			lock (priceLevels)
			{
				foreach (var level in priceLevels)
				{
					double levelPrice = level.Key;
					string description = level.Value;

					if (!levelCrossTracker.ContainsKey(levelPrice))
					{
						levelCrossTracker[levelPrice] = new LevelCrossInfo
						{
							CrossedAbove = false,
							CrossedBelow = false,
							CrossTime = DateTime.MinValue,
							Description = description
						};
					}

					var crossInfo = levelCrossTracker[levelPrice];

					// Check if price crossed above the level
					if (previousPrice <= levelPrice && currentPrice > levelPrice)
					{
						crossInfo.CrossedAbove = true;
						crossInfo.CrossedBelow = false;
						crossInfo.CrossTime = Time[0];
						Print(string.Format("{0}: Price crossed ABOVE {1} at {2:F2}", Time[0], description, levelPrice));
					}
					// Check if price crossed below the level
					else if (previousPrice >= levelPrice && currentPrice < levelPrice)
					{
						crossInfo.CrossedBelow = true;
						crossInfo.CrossedAbove = false;
						crossInfo.CrossTime = Time[0];
						Print(string.Format("{0}: Price crossed BELOW {1} at {2:F2}", Time[0], description, levelPrice));
					}
				}
			}
		}

		private void CheckForBuySignals(double currentPrice, double previousPrice)
		{
			// Don't enter new long if already long
			if (Position.MarketPosition == MarketPosition.Long)
				return;

			// Check for buy conditions based on level descriptions
			if (ShouldBuyAtLevel(currentPrice, previousPrice))
			{
				EnterLong("Buy at Support/Pivot Bull");

				if (EnableStopLoss)
					SetStopLoss(CalculationMode.Ticks, StopLossTicks);

				if (EnableProfitTarget)
					SetProfitTarget(CalculationMode.Ticks, ProfitTargetTicks);

				if (EnableTrailStop)
					SetTrailStop(CalculationMode.Ticks, TrailStopTicks);
			}
		}

		private void CheckForSellSignals(double currentPrice, double previousPrice)
		{
			// Don't enter new short if already short
			if (Position.MarketPosition == MarketPosition.Short)
				return;

			// Check for sell conditions based on level descriptions
			if (ShouldSellAtLevel(currentPrice, previousPrice))
			{
				EnterShort("Sell at Resistance/Pivot Bear");

				if (EnableStopLoss)
					SetStopLoss(CalculationMode.Ticks, StopLossTicks);

				if (EnableProfitTarget)
					SetProfitTarget(CalculationMode.Ticks, ProfitTargetTicks);

				if (EnableTrailStop)
					SetTrailStop(CalculationMode.Ticks, TrailStopTicks);
			}
		}

		private void UpdatePriceLevelsFromChart()
		{
			priceLevels.Clear();

			if (ChartControl == null || ChartPanel == null)
			{
				Print(string.Format("{0}: ChartControl is null - strategy must be run on a chart", Time[0]));
				return;
			}

			try
			{
				// First, collect all Text objects to build a description lookup by price
				Dictionary<double, string> textDescriptionsByPrice = new Dictionary<double, string>();

				// First, try to get drawing objects from DrawObjects collection (indicator-drawn objects)
				if (DrawObjects != null && DrawObjects.Count > 0)
				{
					Print(string.Format("{0}: Scanning {1} objects in DrawObjects collection", Time[0], DrawObjects.Count));

					// Count object types for diagnostics
					Dictionary<string, int> objectTypeCounts = new Dictionary<string, int>();

					// First pass: collect all text descriptions
					foreach (var drawObject in DrawObjects)
					{
						if (drawObject == null)
							continue;

						// Track object types
						string typeName = drawObject.GetType().Name;
						if (!objectTypeCounts.ContainsKey(typeName))
							objectTypeCounts[typeName] = 0;
						objectTypeCounts[typeName]++;

						if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Text)
						{
							var text = drawObject as NinjaTrader.NinjaScript.DrawingTools.Text;
							double textPrice = text.Anchor.Price;
							string displayText = text.DisplayText ?? text.Tag ?? string.Empty;

							if (!string.IsNullOrEmpty(displayText))
							{
								// Round to nearest tick to match with lines
								double roundedPrice = Math.Round(textPrice / TickSize) * TickSize;
								textDescriptionsByPrice[roundedPrice] = displayText;
								Print(string.Format("  Found Text at {0:F2}: {1}", roundedPrice, displayText));
							}
						}
					}

					// Print object type summary
					Print("  DrawObject type summary:");
					foreach (var kvp in objectTypeCounts)
					{
						Print(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
					}

					// Second pass: process lines and rays, matching them with nearby text
					int debugCount = 0;
					foreach (var drawObject in DrawObjects)
					{
						if (drawObject == null)
							continue;

						string tag = string.Empty;
						double priceLevel = 0;
						string description = string.Empty;

						if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Line)
						{
							var line = drawObject as NinjaTrader.NinjaScript.DrawingTools.Line;
							priceLevel = line.StartAnchor.Price;
							tag = line.Tag ?? string.Empty;
							description = tag;

							// Debug first few objects
							if (debugCount < 3)
							{
								Print(string.Format("  DEBUG Line: Price={0:F2}, Tag='{1}', IsLocked={2}", priceLevel, tag, line.IsLocked));
								debugCount++;
							}
						}
						else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine)
						{
							var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
							priceLevel = hLine.StartAnchor.Price;
							tag = hLine.Tag ?? string.Empty;
							description = tag;

							// Debug first few objects - check all possible properties
							if (debugCount < 5)
							{
								try
								{
									// Try to get description from various properties
									string name = "";
									try { name = hLine.GetType().GetProperty("Name")?.GetValue(hLine)?.ToString() ?? ""; } catch { }

									string attachedTo = "";
									try { attachedTo = hLine.AttachedTo?.ToString() ?? ""; } catch { }

									Print(string.Format("  DEBUG HorizontalLine #{0}:", debugCount + 1));
									Print(string.Format("    Price={0:F2}", priceLevel));
									Print(string.Format("    Tag='{0}'", tag));
									Print(string.Format("    Name='{0}'", name));
									Print(string.Format("    AttachedTo='{0}'", attachedTo));
									Print(string.Format("    IsLocked={0}", hLine.IsLocked));
									Print(string.Format("    Stroke='{0}'", hLine.Stroke?.Brush?.ToString() ?? "null"));
								}
								catch (Exception ex)
								{
									Print(string.Format("  DEBUG Error: {0}", ex.Message));
								}
								debugCount++;
							}
						}
						else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Ray)
						{
							var ray = drawObject as NinjaTrader.NinjaScript.DrawingTools.Ray;
							priceLevel = ray.StartAnchor.Price;
							tag = ray.Tag ?? string.Empty;
							description = tag;

							// Debug first few objects
							if (debugCount < 3)
							{
								Print(string.Format("  DEBUG Ray: Price={0:F2}, Tag='{1}', IsLocked={2}", priceLevel, tag, ray.IsLocked));
								debugCount++;
							}
						}

						if (priceLevel > 0)
						{
							// If no description from tag, look for nearby text within 2 ticks
							if (string.IsNullOrEmpty(description))
							{
								double roundedPrice = Math.Round(priceLevel / TickSize) * TickSize;

								// Try exact match first
								if (textDescriptionsByPrice.ContainsKey(roundedPrice))
								{
									description = textDescriptionsByPrice[roundedPrice];
								}
								else
								{
									// Try within 2 ticks
									double proximityInPrice = 2 * TickSize;
									foreach (var kvp in textDescriptionsByPrice)
									{
										if (Math.Abs(kvp.Key - roundedPrice) <= proximityInPrice)
										{
											description = kvp.Value;
											break;
										}
									}
								}
							}

							if (!string.IsNullOrEmpty(description))
							{
								lock (priceLevels)
								{
									if (!priceLevels.ContainsKey(priceLevel))
									{
										priceLevels[priceLevel] = description;
										Print(string.Format("  Added from DrawObjects: {0:F2} - {1}", priceLevel, description));
									}
								}
							}
						}
					}
				}

				// Also scan ChartControl.ChartObjects for manually drawn objects
				// IMPORTANT: This is where Chart Objects window shows the objects
				ChartControl.Dispatcher.InvokeAsync(() =>
				{
					try
					{
						if (ChartControl.ChartObjects != null && ChartControl.ChartObjects.Count > 0)
						{
							Print(string.Format("{0}: *** Scanning {1} objects in ChartObjects (Chart Objects Window) ***", Time[0], ChartControl.ChartObjects.Count));

							// Find the PTZDailyPlanURLv2 indicator in ChartObjects
							object ptzIndicator = null;
							foreach (var chartObject in ChartControl.ChartObjects.ToList())
							{
								if (chartObject != null && chartObject.GetType().Name == "PTZDailyPlanURLv2")
								{
									ptzIndicator = chartObject;
									Print(string.Format("  Found PTZDailyPlanURLv2 indicator in ChartObjects!"));

									// Try to access the indicator's public properties/methods using reflection
									try
									{
										var indicatorType = ptzIndicator.GetType();
										var properties = indicatorType.GetProperties();

										Print(string.Format("  PTZDailyPlanURLv2 has {0} properties:", properties.Length));

										// Look for properties that might contain collection/dictionary of levels
										foreach (var prop in properties)
										{
											string propName = prop.Name;
											var propType = prop.PropertyType;

											// Look for collections, dictionaries, or arrays that might store level data
											bool isCollection = propType.IsGenericType &&
											    (propType.GetGenericTypeDefinition() == typeof(Dictionary<,>) ||
											     propType.GetGenericTypeDefinition() == typeof(List<>) ||
											     propType.Name.Contains("Collection"));

											bool isArray = propType.IsArray;

											// Look for properties with relevant names or collection types
											if (isCollection || isArray ||
											    propName.Contains("Level") || propName.Contains("Price") ||
											    propName.Contains("Support") || propName.Contains("Resistance") ||
											    propName.Contains("Pivot") || propName.Contains("Bull") || propName.Contains("Bear") ||
											    propName.Contains("Line") || propName.Contains("Zone") || propName.Contains("Data"))
											{
												try
												{
													var value = prop.GetValue(ptzIndicator);
													string valueStr = value?.ToString() ?? "null";
													string typeStr = propType.Name;

													// If it's a collection, show count
													if (value != null)
													{
														if (value is System.Collections.ICollection collection)
														{
															valueStr = string.Format("{0} (Count: {1})", typeStr, collection.Count);
														}
														else if (value is System.Collections.IDictionary dict)
														{
															valueStr = string.Format("{0} (Count: {1})", typeStr, dict.Count);
														}
													}

													Print(string.Format("    Property '{0}' [{1}] = {2}", propName, typeStr, valueStr));
												}
												catch (Exception ex)
												{
													Print(string.Format("    Property '{0}' - Error: {1}", propName, ex.Message));
												}
											}
										}

										// Also check for common indicator value series
										var valuesProperty = indicatorType.GetProperty("Values");
										if (valuesProperty != null)
										{
											var values = valuesProperty.GetValue(ptzIndicator);
											if (values != null)
											{
												Print(string.Format("  Indicator has Values collection: {0}", values.GetType().Name));
											}
										}
									}
									catch (Exception ex)
									{
										Print(string.Format("  Error inspecting PTZDailyPlanURLv2: {0}", ex.Message));
									}
									break;
								}
							}

							if (ptzIndicator == null)
							{
								Print("  WARNING: PTZDailyPlanURLv2 indicator not found in ChartObjects");
							}

							// Count types in ChartObjects
							Dictionary<string, int> chartObjectTypeCounts = new Dictionary<string, int>();
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject != null)
								{
									string typeName = drawObject.GetType().Name;
									if (!chartObjectTypeCounts.ContainsKey(typeName))
										chartObjectTypeCounts[typeName] = 0;
									chartObjectTypeCounts[typeName]++;
								}
							}

							Print("  ChartObject type summary:");
							foreach (var kvp in chartObjectTypeCounts)
							{
								Print(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
							}

							// First pass: collect text descriptions from ChartObjects
							Dictionary<double, string> chartTextDescriptions = new Dictionary<double, string>();
							int chartDebugCount = 0;
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject == null)
									continue;

								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Text)
								{
									var text = drawObject as NinjaTrader.NinjaScript.DrawingTools.Text;
									double textPrice = text.Anchor.Price;
									string displayText = text.DisplayText ?? text.Tag ?? string.Empty;

									if (!string.IsNullOrEmpty(displayText))
									{
										double roundedPrice = Math.Round(textPrice / TickSize) * TickSize;
										chartTextDescriptions[roundedPrice] = displayText;
										Print(string.Format("  Found ChartObject Text at {0:F2}: {1}", roundedPrice, displayText));
									}
								}

								// Debug HorizontalLines from ChartObjects
								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine && chartDebugCount < 5)
								{
									var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
									try
									{
										string tag = hLine.Tag ?? "";
										string name = "";
										try { name = hLine.GetType().GetProperty("Name")?.GetValue(hLine)?.ToString() ?? ""; } catch { }

										Print(string.Format("  DEBUG ChartObject HorizontalLine #{0}:", chartDebugCount + 1));
										Print(string.Format("    Price={0:F2}", hLine.StartAnchor.Price));
										Print(string.Format("    Tag='{0}'", tag));
										Print(string.Format("    Name='{0}'", name));
									}
									catch (Exception ex)
									{
										Print(string.Format("  DEBUG ChartObject Error: {0}", ex.Message));
									}
									chartDebugCount++;
								}
							}

							// Second pass: process lines and match with text
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject == null)
									continue;

								string tag = string.Empty;
								double priceLevel = 0;
								string description = string.Empty;

								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Line)
								{
									var line = drawObject as NinjaTrader.NinjaScript.DrawingTools.Line;
									priceLevel = line.StartAnchor.Price;
									tag = line.Tag ?? string.Empty;
									description = tag;
								}
								else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine)
								{
									var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
									priceLevel = hLine.StartAnchor.Price;
									tag = hLine.Tag ?? string.Empty;
									description = tag;
								}
								else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Ray)
								{
									var ray = drawObject as NinjaTrader.NinjaScript.DrawingTools.Ray;
									priceLevel = ray.StartAnchor.Price;
									tag = ray.Tag ?? string.Empty;
									description = tag;
								}

								if (priceLevel > 0)
								{
									// If no description from tag, look for nearby text within 2 ticks
									if (string.IsNullOrEmpty(description))
									{
										double roundedPrice = Math.Round(priceLevel / TickSize) * TickSize;

										// Try exact match first
										if (chartTextDescriptions.ContainsKey(roundedPrice))
										{
											description = chartTextDescriptions[roundedPrice];
										}
										else
										{
											// Try within 2 ticks
											double proximityInPrice = 2 * TickSize;
											foreach (var kvp in chartTextDescriptions)
											{
												if (Math.Abs(kvp.Key - roundedPrice) <= proximityInPrice)
												{
													description = kvp.Value;
													break;
												}
											}
										}
									}

									if (!string.IsNullOrEmpty(description))
									{
										lock (priceLevels)
										{
											if (!priceLevels.ContainsKey(priceLevel))
											{
												priceLevels[priceLevel] = description;
												Print(string.Format("  Added from ChartObjects: {0:F2} - {1}", priceLevel, description));
											}
										}
									}
								}
							}
						}
					}
					catch (Exception ex)
					{
						Print(string.Format("Error in ChartObjects Dispatcher: {0}", ex.Message));
					}
				});

				// Give dispatcher time to complete
				System.Threading.Thread.Sleep(100);

				int levelCount = 0;
				lock (priceLevels)
				{
					levelCount = priceLevels.Count;
				}

				if (levelCount > 0)
				{
					Print(string.Format("{0}: Successfully loaded {1} price levels", Time[0], levelCount));

					// Print details of each level for debugging
					lock (priceLevels)
					{
						foreach (var level in priceLevels)
						{
							Print(string.Format("  Active Level: {0:F2} - {1}", level.Key, level.Value));
						}
					}
				}
				else
				{
					Print(string.Format("{0}: WARNING - No price levels found. Check:", Time[0]));
					Print("  1. Indicator is loaded on the chart");
					Print("  2. Indicator has drawn levels with text labels");
					Print("  3. Drawing objects have tags or text descriptions");
					Print(string.Format("  DrawObjects count: {0}", DrawObjects != null ? DrawObjects.Count : 0));
				}
			}
			catch (Exception ex)
			{
				Print(string.Format("Error updating price levels: {0}", ex.Message));
				Print(string.Format("Stack trace: {0}", ex.StackTrace));
			}
		}

		private bool ShouldBuyAtLevel(double currentPrice, double previousPrice)
		{
			lock (priceLevels)
			{
				if (priceLevels.Count == 0)
					return false;

				double proximity = PriceProximityTicks * TickSize;

				foreach (var level in priceLevels)
				{
					double levelPrice = level.Key;
					string description = level.Value.ToLower();

					// Apply LBL filter if enabled
					if (UseLBLFilter)
					{
						bool hasLBL = description.Contains("lbl");

						// If RequireLBLInDescription is true, only trade levels WITH "LBL"
						// If RequireLBLInDescription is false, only trade levels WITHOUT "LBL"
						if (RequireLBLInDescription && !hasLBL)
							continue;
						if (!RequireLBLInDescription && hasLBL)
							continue;
					}

					bool isBuyLevel = false;

					if (UseSupport && description.Contains(KeywordSupport.ToLower()))
						isBuyLevel = true;
					if (UsePivotBull && description.Contains(KeywordPivotBull.ToLower()))
						isBuyLevel = true;
					if (UseStrengthConfirmed && description.Contains(KeywordStrengthConfirmed.ToLower()))
						isBuyLevel = true;

					if (isBuyLevel)
					{
						// Check if we have cross tracking info for this level
						if (levelCrossTracker.ContainsKey(levelPrice))
						{
							var crossInfo = levelCrossTracker[levelPrice];

							// For BUY at support: Price crossed below the level, now retracing back above
							if (crossInfo.CrossedBelow && previousPrice < levelPrice && currentPrice >= levelPrice)
							{
								Print(string.Format("{0}: BUY Signal - Price retraced back above {1} at {2:F2} after crossing below", Time[0], description, levelPrice));
								crossInfo.CrossedBelow = false; // Reset to avoid duplicate entries
								return true;
							}
						}

						// Also allow immediate touch/crossover if configured
						if (TradeOnCrossover)
						{
							// For support: Enter on initial cross below then back above
							if (previousPrice < levelPrice - proximity && currentPrice >= levelPrice)
							{
								Print(string.Format("{0}: BUY Signal - Price crossed above {1} at {2:F2}", Time[0], description, levelPrice));
								return true;
							}
						}

						if (TradeOnTouch)
						{
							// Touch from below
							if (currentPrice >= levelPrice - proximity && currentPrice <= levelPrice + proximity)
							{
								Print(string.Format("{0}: BUY Signal - Price touching {1} at {2:F2}", Time[0], description, levelPrice));
								return true;
							}
						}
					}
				}

				return false;
			}
		}

		private bool ShouldSellAtLevel(double currentPrice, double previousPrice)
		{
			lock (priceLevels)
			{
				if (priceLevels.Count == 0)
					return false;

				double proximity = PriceProximityTicks * TickSize;

				foreach (var level in priceLevels)
				{
					double levelPrice = level.Key;
					string description = level.Value.ToLower();

					// Apply LBL filter if enabled
					if (UseLBLFilter)
					{
						bool hasLBL = description.Contains("lbl");

						// If RequireLBLInDescription is true, only trade levels WITH "LBL"
						// If RequireLBLInDescription is false, only trade levels WITHOUT "LBL"
						if (RequireLBLInDescription && !hasLBL)
							continue;
						if (!RequireLBLInDescription && hasLBL)
							continue;
					}

					bool isSellLevel = false;

					if (UseResistance && description.Contains(KeywordResistance.ToLower()))
						isSellLevel = true;
					if (UsePivotBear && description.Contains(KeywordPivotBear.ToLower()))
						isSellLevel = true;
					if (UseWeaknessConfirmed && description.Contains(KeywordWeaknessConfirmed.ToLower()))
						isSellLevel = true;

					if (isSellLevel)
					{
						// Check if we have cross tracking info for this level
						if (levelCrossTracker.ContainsKey(levelPrice))
						{
							var crossInfo = levelCrossTracker[levelPrice];

							// For SELL at resistance: Price crossed above the level, now retracing back below
							if (crossInfo.CrossedAbove && previousPrice > levelPrice && currentPrice <= levelPrice)
							{
								Print(string.Format("{0}: SELL Signal - Price retraced back below {1} at {2:F2} after crossing above", Time[0], description, levelPrice));
								crossInfo.CrossedAbove = false; // Reset to avoid duplicate entries
								return true;
							}
						}

						// Also allow immediate touch/crossover if configured
						if (TradeOnCrossover)
						{
							// For resistance: Enter on initial cross above then back below
							if (previousPrice > levelPrice + proximity && currentPrice <= levelPrice)
							{
								Print(string.Format("{0}: SELL Signal - Price crossed below {1} at {2:F2}", Time[0], description, levelPrice));
								return true;
							}
						}

						if (TradeOnTouch)
						{
							// Touch from above
							if (currentPrice >= levelPrice - proximity && currentPrice <= levelPrice + proximity)
							{
								Print(string.Format("{0}: SELL Signal - Price touching {1} at {2:F2}", Time[0], description, levelPrice));
								return true;
							}
						}
					}
				}

				return false;
			}
		}

		#region Properties

		[NinjaScriptProperty]
		[Display(Name="Use Support Levels", Description="Enable trading at Support levels", Order=1, GroupName="1) Level Types")]
		public bool UseSupport
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Resistance Levels", Description="Enable trading at Resistance levels", Order=2, GroupName="1) Level Types")]
		public bool UseResistance
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Pivot Bull Levels", Description="Enable trading at Pivot Bull levels", Order=3, GroupName="1) Level Types")]
		public bool UsePivotBull
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Pivot Bear Levels", Description="Enable trading at Pivot Bear levels", Order=4, GroupName="1) Level Types")]
		public bool UsePivotBear
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Strength Confirmed", Description="Enable trading at Strength Confirmed levels", Order=5, GroupName="1) Level Types")]
		public bool UseStrengthConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Weakness Confirmed", Description="Enable trading at Weakness Confirmed levels", Order=6, GroupName="1) Level Types")]
		public bool UseWeaknessConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, int.MaxValue)]
		[Display(Name="Price Proximity (Ticks)", Description="How close price must be to trigger (in ticks)", Order=1, GroupName="2) Entry Rules")]
		public int PriceProximityTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Trade on Crossover", Description="Enter when price crosses the level", Order=2, GroupName="2) Entry Rules")]
		public bool TradeOnCrossover
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Trade on Touch", Description="Enter when price touches/is near the level", Order=3, GroupName="2) Entry Rules")]
		public bool TradeOnTouch
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use LBL Filter", Description="Enable filtering based on LBL keyword in descriptions", Order=4, GroupName="2) Entry Rules")]
		public bool UseLBLFilter
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Require LBL in Description", Description="If enabled: only trade levels WITH 'LBL'. If disabled: only trade levels WITHOUT 'LBL'", Order=5, GroupName="2) Entry Rules")]
		public bool RequireLBLInDescription
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Stop Loss", Description="Use stop loss orders", Order=1, GroupName="3) Risk Management")]
		public bool EnableStopLoss
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Stop Loss (Ticks)", Description="Stop loss distance in ticks", Order=2, GroupName="3) Risk Management")]
		public int StopLossTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Profit Target", Description="Use profit target orders", Order=3, GroupName="3) Risk Management")]
		public bool EnableProfitTarget
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Profit Target (Ticks)", Description="Profit target distance in ticks", Order=4, GroupName="3) Risk Management")]
		public int ProfitTargetTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Trail Stop", Description="Use trailing stop orders", Order=5, GroupName="3) Risk Management")]
		public bool EnableTrailStop
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Trail Stop (Ticks)", Description="Trailing stop distance in ticks", Order=6, GroupName="3) Risk Management")]
		public int TrailStopTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Support Keyword", Description="Keyword to identify support levels", Order=1, GroupName="4) Keywords")]
		public string KeywordSupport
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Resistance Keyword", Description="Keyword to identify resistance levels", Order=2, GroupName="4) Keywords")]
		public string KeywordResistance
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Pivot Bull Keyword", Description="Keyword to identify pivot bull levels", Order=3, GroupName="4) Keywords")]
		public string KeywordPivotBull
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Pivot Bear Keyword", Description="Keyword to identify pivot bear levels", Order=4, GroupName="4) Keywords")]
		public string KeywordPivotBear
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Strength Confirmed Keyword", Description="Keyword to identify strength confirmed levels", Order=5, GroupName="4) Keywords")]
		public string KeywordStrengthConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Weakness Confirmed Keyword", Description="Keyword to identify weakness confirmed levels", Order=6, GroupName="4) Keywords")]
		public string KeywordWeaknessConfirmed
		{ get; set; }

		#endregion
	}
}
